<style>
    .canvasContainer {
        position: relative;
    }

    .canvasContainer canvas {
        position: absolute;
        left: 0;
        top: 0;
    }
</style>

<div class="canvasContainer">
    <canvas id="grid" width="600px" height="600px"></canvas>
    <canvas id="fn2" width="600px" height="600px"></canvas>
    <canvas id="gp_mean" width="600px" height="600px"></canvas>
    <canvas id="observations" width="600px" height="600px"></canvas>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.4/math.min.js"></script>
<script src="graphplot.js" type="module"></script>
<script type="module">
    import {drawFunction, drawGrid, drawPoints, xPixToCoord, xCoordToPix} from './graphplot.js';

    const canvas = document.getElementById("grid");
    const config = {
        xMin: -0.2,
        xMax: 3.4,
        yMin: -0.2,
        yMax: 4.2,
        ctx: canvas.getContext("2d")
    };

    const canvasF2 = document.getElementById("fn2");
    const configF2 = Object.assign({}, config);
    configF2.ctx = canvasF2.getContext("2d");

    const canvasObs = document.getElementById("observations");
    const configObs = Object.assign({}, config);
    configObs.ctx = canvasObs.getContext("2d");

    const canvasGpMean = document.getElementById("gp_mean");
    const configGpMean = Object.assign({}, config);
    configGpMean.ctx = canvasGpMean.getContext("2d");

    drawGrid(config);
    const func = x => {
        if ((x < 0) || (x > Math.PI)) return 0;
        let result = 0;
        for (let i = 1; i <= 10; i++) {
            result += Math.sin(x) * Math.pow(Math.sin(i * x * x / Math.PI), 20);
        }
        return result;
    };
    drawFunction(configF2, "#000000", func);

    let observationsX = [0.9, 1.2, 1.5, 1.6, 2.1, 2.5, 2.8];
    let observationsY = observationsX.map(x => func(x));
    let observations = observationsX.map(x => [x, func(x)]);
    drawPoints(
        configObs,
        "#0000FF",
        observations
    );

    const kernel = function (x1, x2) {
        let n = math.norm(math.subtract(x1, x2));
        return math.exp(-0.5 * n * n);
    }

    const K = function (x0, x1, kernel) {
        let K = [];
        for (let x0i of x0) {
            let k_x_x = [];
            for (let x1i of x1) {
                k_x_x.push(kernel(x0i, x1i));
            }
            K.push(k_x_x);
        }
        return K;
    }

    const posterioriMean = function (x, x_new, sigma, y, kernel) {
        let scope = {
            x_new: x_new,
            x: x,
            xl: x.length,
            sigma: sigma,
            y: y,
            K: (x1, x2) => K(x1, x2, kernel)
        }
        return math.evaluate('K(x_new,x) * inv(K(x,x) + sigma .* identity(xl)) * transpose(y)', scope);
    }

    const zip = function (a, b) {
        let zip = [];
        for (let i = 0; i < a.length; i++) {
            zip.push([a[i], b[i]]);
        }
        return zip;
    }

    const x_new = [];
    const xCoordStart = xCoordToPix(config, -0.2);
    const xCoordEnd = xCoordToPix(config, 3.4);
    for (let i = xCoordStart; i < xCoordEnd; i++) {
        x_new.push(xPixToCoord(config, i))
    }
    const y_new = posterioriMean(observationsX, x_new, 0.00000000, observationsY, kernel).valueOf();
    const xy_new = zip(x_new, y_new);
    drawPoints(
        configGpMean,
        "#00FF00",
        xy_new
    );
    drawFunction(configGpMean, "#00ff00", (x)=> {
        const w = xCoordToPix(config, x);
        return y_new[w-xCoordStart];
    });

</script>


<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
<div style="width:600px;padding-top:620px">
    <h3>Plot of function</h3>

    <p>
        \[ f(x) = \sum_{i=1}^{10}\sin(x)\ \sin(\frac{i\ x^2}{\pi})^{20} \]
    </p>
</div>